---
description: 
globs: *.ts,*.tsx,*tsconfig.json
alwaysApply: false
---
# TypeScript Best Practices

## ‚ú® Core Principles

1.  **Strong Typing:** Utilize TypeScript's type system rigorously. Avoid `any` wherever possible. Leverage type inference but provide explicit types for function signatures, complex objects, and public APIs.
2.  **Type Generation:** Use `wrangler types` to generate accurate types (`worker-configuration.d.ts`) based on your `wrangler.jsonc` configuration (compatibility date/flags, bindings). Ensure this is included in your `tsconfig.json` `types` array.
3.  **Interfaces vs. Types:** Prefer `interface` for defining the shape of objects and implementing classes (though classes are discouraged). Use `type` for unions, intersections, primitives, and more complex type manipulations.
4.  **Functional Programming:** Favor pure functions, immutability, and declarative patterns over imperative code and side effects where practical. Avoid classes unless necessary for specific patterns (like Cloudflare Durable Objects).
5.  **Modularity:** Break down logic into small, reusable functions. Iterate over collections using standard array methods (`map`, `filter`, `reduce`) instead of complex loops where it enhances readability.
6.  **Descriptive Naming:** Use clear and descriptive names for variables, functions, and types. Use boolean prefixes like `is`, `has`, `should` for boolean variables (e.g., `isLoading`, `hasError`).
7.  **RORO Pattern:** For functions accepting multiple options or complex parameters, use the "Receive an Object, Return an Object" (RORO) pattern for clarity and easier refactoring.

## üõ°Ô∏è Error Handling & Validation

1.  **Guard Clauses:** Use early returns (guard clauses) at the beginning of functions to handle preconditions, invalid states, or error conditions. This reduces nesting and keeps the main logic path clear.

    ```typescript
    function processData(data: Data | null): Result | null {
      if (!data) {
        console.error("Invalid data provided");
        return null; // Early return
      }

      // --- Happy path ---
      const result = // ... process data
      return result;
    }
    ```

2.  **Avoid Unnecessary `else`:** After an `if` block with a `return` (or `throw`), avoid using an `else` block for the main logic path.
3.  **Explicit Error Handling:** Use `try...catch` blocks for operations that can throw exceptions (e.g., JSON parsing, network requests). Provide informative error messages or logging.
4.  **Validation:** Validate external data (API responses, user input) using libraries like Zod or custom type guards before using it in your application logic.
